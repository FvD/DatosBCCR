datos <- DescargarDatosBCCR(c(317,318), inicio = "01/01/2010")
datos
help(melt)
library(reshape2)
help(melt)
datos %>% melt(id = "Fecha") %>% ggplot(aes(x = Fecha, y = Value)) + geom_line()
library(dplyr)
datos %>% melt(id = "Fecha") %>% ggplot(aes(x = Fecha, y = Value)) + geom_line()
library(ggplot2)
datos %>% melt(id = "Fecha") %>% ggplot(aes(x = Fecha, y = Value)) + geom_line()
datos %>% melt(id = "Fecha")
library(tidyr)
help(spread)
datos %>% gather(TDC, valor, -Fecha)
datos %>% gather(TDC, valor, -Fecha) %>% ggplot(aes(x = Fecha, y = Valor, col = TDC)) + geom_line()
datos %>% gather(TDC, valor, -Fecha) %>% ggplot(aes(x = Fecha, y = valor, col = TDC)) + geom_line()
datos <- DescargarDatosBCCR(c(317,318))
datos %>% gather(TDC, valor, -Fecha) %>% ggplot(aes(x = Fecha, y = valor, col = TDC)) + geom_line()
datos %>% gather(TDC, valor, -Fecha) %>% filter(Fecha > "01-01-2006") %>% ggplot(aes(x = Fecha, y = valor, col = TDC)) + geom_line()
datos %>% gather(TDC, valor, -Fecha) %>% filter(Fecha > as.Date("01-01-2006")) %>% ggplot(aes(x = Fecha, y = valor, col = TDC)) + geom_line()
datos$Fecha
datos %>% gather(TDC, valor, -Fecha) %>% filter(Fecha > "2010-01-01" %>% ggplot(aes(x = Fecha, y = valor, col = TDC)) + geom_line()
datos %>% gather(TDC, valor, -Fecha) %>% filter(Fecha > "2010-01-01") %>% ggplot(aes(x = Fecha, y = valor, col = TDC)) + geom_line()
datos %>% gather(TDC, valor, -Fecha) %>% filter(Fecha > "2006-01-01") %>% ggplot(aes(x = Fecha, y = valor, col = TDC)) + geom_line()
datos %>% gather(TDC, valor, -Fecha) %>% filter(Fecha > "2006-01-01") %>% ggplot(aes(x = Fecha, y = valor, col = TDC)) + geom_line(lwd = 1)
datos %>% gather(TDC, valor, -Fecha) %>% filter(Fecha > "2006-01-01") %>% ggplot(aes(x = Fecha, y = valor, col = TDC)) + geom_line(lwd = 1.25)
datos %>% gather(TDC, valor, -Fecha) %>% filter(Fecha > "2006-01-01") %>% ggplot(aes(x = Fecha, y = valor, col = TDC)) + geom_line(lwd = 1.0)
datos %>% gather(TDC, valor, -Fecha) %>% filter(Fecha > "2006-01-01") %>% ggplot(aes(x = Fecha, y = valor, col = TDC)) + geom_line(lwd = 1.0) + theme_bw()
library(DatosBCCR)
datos <- DescargarDatosBCCR(1, subniveles = "S")
datos
datos$`Cuenta corriente`
datos$"Cuenta corriente""
datos$"Cuenta corriente"
datos
tail(datos)
help(spread)
library(tidyr)
help(spread)
unique()
library(DatosBCCR)
datos <- DescargarDatosBCCR(1, subniveles = "S")
temp
metada <- dplyr::filter(cods, Indicador %in% t(temp$COD_INDICADORINTERNO))
metada <- dplyr::filter(cods, Indicador %in% t(temp)$COD_INDICADORINTERNO)
temp
library(DatosBCCR)
datos <- DescargarDatosBCCR(1, subniveles = "S")
library(DatosBCCR)
datos <- DescargarDatosBCCR(1, subniveles = "S")
,data
data
temp
library(DatosBCCR)
datos <- DescargarDatosBCCR(1, subniveles = "S")
cods
ind
temp
x <- matrix(11)
matrix$1
matrix$a
matrix[1]
matrix[[1]]
library(DatosBCCR)
datos <- DescargarDatosBCCR(1, subniveles = "S")
library(DatosBCCR)
datos <- DescargarDatosBCCR(1, subniveles = "S")
library(DatosBCCR)
datos <- DescargarDatosBCCR(1, subniveles = "S")
temp
`*tno*`
`*tmp*`
temp
cods
left_join
library(dplyr)
help("semi_join")
cods
help(as_tibble)
help("as.data.frame")
indicador = 1
inicio="11/02/1989"
fin = "hoy"
subniveles = "N"
nombre= "me"
if (fin == "hoy") fin = strftime(Sys.time(),"%d/%m/%Y")
for (ind in indicador) {
if (!as.character(ind) %in% cods$Indicador) next
serverResponse <- httr::status_code(httr::GET(url))
if (serverResponse == 200) {
htmlRequest <- RCurl::getForm(baseSource,
tcIndicador = ind, tcFechaInicio = inicio,
tcFechaFinal = fin, tcNombre = nombre,
tnSubNiveles = subniveles)
}else stop("No se ha podido conectar al servidor.")
# Deshacerse del tag <string> que no permite usar xmlTreeParse
# y luege obtener datos
temp <- htmlRequest %>% XML::htmlParse(asText = TRUE) %>%
XML::xpathSApply("//string", XML::xmlValue) %>%
XML::xmlTreeParse() %>% XML::xmlRoot() %>%
XML::xmlSApply(function(x) XML::xmlSApply(x,
XML::xmlValue))
# Corregir series para las que el sistema retorna valores vacíos
# para determinadas fechas (v.gr. fines de semana)
if (class(temp) == "list") {
temp <- sapply(temp,
function(x) {if (is.na(x[3])) x <- c(x, "NA"); x})
}
url <- paste("http://indicadoreseconomicos.bccr.fi.cr/",
"indicadoreseconomicos/WebServices/wsIndicadoresEconomicos.asmx",
sep = "")
baseSource <- paste(url,"/ObtenerIndicadoresEconomicosXML",
sep = "")
if (!as.character(ind) %in% cods$Indicador) next
serverResponse <- httr::status_code(httr::GET(url))
if (serverResponse == 200) {
htmlRequest <- RCurl::getForm(baseSource,
tcIndicador = ind, tcFechaInicio = inicio,
tcFechaFinal = fin, tcNombre = nombre,
tnSubNiveles = subniveles)
}else stop("No se ha podido conectar al servidor.")
# Deshacerse del tag <string> que no permite usar xmlTreeParse
# y luege obtener datos
temp <- htmlRequest %>% XML::htmlParse(asText = TRUE) %>%
XML::xpathSApply("//string", XML::xmlValue) %>%
XML::xmlTreeParse() %>% XML::xmlRoot() %>%
XML::xmlSApply(function(x) XML::xmlSApply(x,
XML::xmlValue))
temp
tx <- as_tibble(temp, col.names = c("Indicador",
"Fecha", "Valor")) %>% dplyr::left_join(cods), "Indicador") %>%
dplyr::select(-Indicador, -Periodicidad)
tx <- as_tibble(temp, col.names = c("Indicador",
"Fecha", "Valor"))
library(tibble)
tx <- as_tibble(temp, col.names = c("Indicador",
"Fecha", "Valor"))
tx
tx <- as_tibble(t(temp), col.names = c("Indicador",
"Fecha", "Valor"))
tx
temp
temp <- t(temp)
colnames(temp) <- c("Indicador", "Fecha", "Valor")
temp
tx <- as_tibble(temp) %>% dplyr::left_join(cods, "Indicador") %>%
dplyr::select(-Indicador, -Periodicidad)
tx
tx <- as_tibble(temp) %>% dplyr::left_join(cods, "Indicador") %>%
dplyr::select(-Indicador, -Periodicidad) %>% spread(Nombre,
Valor)
tx
temp
tx
help("as_tibble")
subniveles ="S"
if (!as.character(ind) %in% cods$Indicador) next
serverResponse <- httr::status_code(httr::GET(url))
if (serverResponse == 200) {
htmlRequest <- RCurl::getForm(baseSource,
tcIndicador = ind, tcFechaInicio = inicio,
tcFechaFinal = fin, tcNombre = nombre,
tnSubNiveles = subniveles)
}else stop("No se ha podido conectar al servidor.")
# Deshacerse del tag <string> que no permite usar xmlTreeParse
# y luege obtener datos
temp <- htmlRequest %>% XML::htmlParse(asText = TRUE) %>%
XML::xpathSApply("//string", XML::xmlValue) %>%
XML::xmlTreeParse() %>% XML::xmlRoot() %>%
XML::xmlSApply(function(x) XML::xmlSApply(x,
XML::xmlValue))
# Corregir series para las que el sistema retorna valores vacíos
# para determinadas fechas (v.gr. fines de semana)
if (class(temp) == "list") {
temp <- sapply(temp,
function(x) {if (is.na(x[3])) x <- c(x, "NA"); x})
}
metadata <- dplyr::filter(cods,
Indicador %in% temp[1, ])
#Formato de datos
temp <- t(temp)
colnames(temp) <- c("Indicador", "Fecha", "Valor")
#Elimina advertencia por generación de NA's
suppressWarnings(temp$Valor <-
as.numeric(temp$Valor))
temp$Fecha <- as.Date(temp$Fecha, "%Y-%m-%d")
temp <- as_tibble(temp) %>% dplyr::left_join(cods, "Indicador") %>%
dplyr::select(-Indicador, -Periodicidad) %>% spread(Nombre,
Valor)
temp
if (!as.character(ind) %in% cods$Indicador) next
serverResponse <- httr::status_code(httr::GET(url))
if (serverResponse == 200) {
htmlRequest <- RCurl::getForm(baseSource,
tcIndicador = ind, tcFechaInicio = inicio,
tcFechaFinal = fin, tcNombre = nombre,
tnSubNiveles = subniveles)
}else stop("No se ha podido conectar al servidor.")
# Deshacerse del tag <string> que no permite usar xmlTreeParse
# y luege obtener datos
temp <- htmlRequest %>% XML::htmlParse(asText = TRUE) %>%
XML::xpathSApply("//string", XML::xmlValue) %>%
XML::xmlTreeParse() %>% XML::xmlRoot() %>%
XML::xmlSApply(function(x) XML::xmlSApply(x,
XML::xmlValue))
# Corregir series para las que el sistema retorna valores vacíos
# para determinadas fechas (v.gr. fines de semana)
if (class(temp) == "list") {
temp <- sapply(temp,
function(x) {if (is.na(x[3])) x <- c(x, "NA"); x})
}
metadata <- dplyr::filter(cods,
Indicador %in% temp[1, ])
#Formato de datos
temp <- t(temp)
colnames(temp) <- c("Indicador", "Fecha", "Valor")
#Elimina advertencia por generación de NA's
temp
head(temp)
temp$Valor
class(temp)
suppressWarnings(temp[["Valor"]] <-
as.numeric(temp[["Valor"]]))
temp[Valor]
temp["Valor"]
temp[["Valor"]]
temp[, "Valor"]
head(data.frame(temp))
if (!as.character(ind) %in% cods$Indicador) next
serverResponse <- httr::status_code(httr::GET(url))
if (serverResponse == 200) {
htmlRequest <- RCurl::getForm(baseSource,
tcIndicador = ind, tcFechaInicio = inicio,
tcFechaFinal = fin, tcNombre = nombre,
tnSubNiveles = subniveles)
}else stop("No se ha podido conectar al servidor.")
# Deshacerse del tag <string> que no permite usar xmlTreeParse
# y luege obtener datos
temp <- htmlRequest %>% XML::htmlParse(asText = TRUE) %>%
XML::xpathSApply("//string", XML::xmlValue) %>%
XML::xmlTreeParse() %>% XML::xmlRoot() %>%
XML::xmlSApply(function(x) XML::xmlSApply(x,
XML::xmlValue))
# Corregir series para las que el sistema retorna valores vacíos
# para determinadas fechas (v.gr. fines de semana)
if (class(temp) == "list") {
temp <- sapply(temp,
function(x) {if (is.na(x[3])) x <- c(x, "NA"); x})
}
metadata <- dplyr::filter(cods,
Indicador %in% temp[1, ])
#Formato de datos
temp <- data.frame(t(temp),
colnames = c("Indicador", "Fecha", "Valor"))
#Elimina advertencia por generación de NA's
suppressWarnings(temp$Valor <-
as.numeric(temp$Valor))
temp$Fecha <- as.Date(temp$Fecha, "%Y-%m-%d")
temp <- as_tibble(temp) %>% dplyr::left_join(cods, "Indicador") %>%
dplyr::select(-Indicador, -Periodicidad) %>% spread(Nombre,
Valor)
if (!as.character(ind) %in% cods$Indicador) next
serverResponse <- httr::status_code(httr::GET(url))
if (serverResponse == 200) {
htmlRequest <- RCurl::getForm(baseSource,
tcIndicador = ind, tcFechaInicio = inicio,
tcFechaFinal = fin, tcNombre = nombre,
tnSubNiveles = subniveles)
}else stop("No se ha podido conectar al servidor.")
# Deshacerse del tag <string> que no permite usar xmlTreeParse
# y luege obtener datos
temp <- htmlRequest %>% XML::htmlParse(asText = TRUE) %>%
XML::xpathSApply("//string", XML::xmlValue) %>%
XML::xmlTreeParse() %>% XML::xmlRoot() %>%
XML::xmlSApply(function(x) XML::xmlSApply(x,
XML::xmlValue))
# Corregir series para las que el sistema retorna valores vacíos
# para determinadas fechas (v.gr. fines de semana)
if (class(temp) == "list") {
temp <- sapply(temp,
function(x) {if (is.na(x[3])) x <- c(x, "NA"); x})
}
temp
temp <- data.frame(t(temp),
colnames = c("Indicador", "Fecha", "Valor"))
help("colnames")
if (!as.character(ind) %in% cods$Indicador) next
serverResponse <- httr::status_code(httr::GET(url))
if (serverResponse == 200) {
htmlRequest <- RCurl::getForm(baseSource,
tcIndicador = ind, tcFechaInicio = inicio,
tcFechaFinal = fin, tcNombre = nombre,
tnSubNiveles = subniveles)
}else stop("No se ha podido conectar al servidor.")
# Deshacerse del tag <string> que no permite usar xmlTreeParse
# y luege obtener datos
temp <- htmlRequest %>% XML::htmlParse(asText = TRUE) %>%
XML::xpathSApply("//string", XML::xmlValue) %>%
XML::xmlTreeParse() %>% XML::xmlRoot() %>%
XML::xmlSApply(function(x) XML::xmlSApply(x,
XML::xmlValue)) %>% t()
# Corregir series para las que el sistema retorna valores vacíos
# para determinadas fechas (v.gr. fines de semana)
if (class(temp) == "list") {
temp <- sapply(temp,
function(x) {if (is.na(x[3])) x <- c(x, "NA"); x}) %>% t()
}
#Formato de datos
temp <- data.frame(temp, colnames = c("Indicador",
"Fecha", "Valor"))
temp
temp <- as.data.frame(temp, colnames = c("Indicador",
"Fecha", "Valor"))
temp
if (!as.character(ind) %in% cods$Indicador) next
serverResponse <- httr::status_code(httr::GET(url))
if (serverResponse == 200) {
htmlRequest <- RCurl::getForm(baseSource,
tcIndicador = ind, tcFechaInicio = inicio,
tcFechaFinal = fin, tcNombre = nombre,
tnSubNiveles = subniveles)
}else stop("No se ha podido conectar al servidor.")
# Deshacerse del tag <string> que no permite usar xmlTreeParse
# y luege obtener datos
temp <- htmlRequest %>% XML::htmlParse(asText = TRUE) %>%
XML::xpathSApply("//string", XML::xmlValue) %>%
XML::xmlTreeParse() %>% XML::xmlRoot() %>%
XML::xmlSApply(function(x) XML::xmlSApply(x,
XML::xmlValue)) %>% t()
# Corregir series para las que el sistema retorna valores vacíos
# para determinadas fechas (v.gr. fines de semana)
if (class(temp) == "list") {
temp <- sapply(temp,
function(x) {if (is.na(x[3])) x <- c(x, "NA"); x}) %>% t()
}
x  <- s_tibble(temp, colnames = c("Indicador",
"Fecha", "Valor"))
x  <- as_tibble(temp, colnames = c("Indicador",
"Fecha", "Valor"))
x
help("tibble")
temp <- as_tibble(temp)
colnames(temp) <-  c("Indicador", "Fecha", "Valor"))
temp <- as_tibble(temp)
colnames(temp) <-  c("Indicador", "Fecha", "Valor")
temp
suppressWarnings(temp$Valor <-
as.numeric(temp$Valor))
temp$Fecha <- as.Date(temp$Fecha, "%Y-%m-%d")
temp <- as_tibble(temp) %>% dplyr::left_join(cods, "Indicador") %>%
dplyr::select(-Indicador, -Periodicidad) %>% spread(Nombre,
Valor)
temp
head(as.data.frame(temp))
library(DatosBCCR)
datos <- DescargarDatosBCCR(1, subniveles = "S")
temp
x
if (!as.character(ind) %in% cods$Indicador) next
serverResponse <- httr::status_code(httr::GET(url))
if (serverResponse == 200) {
htmlRequest <- RCurl::getForm(baseSource,
tcIndicador = ind, tcFechaInicio = inicio,
tcFechaFinal = fin, tcNombre = nombre,
tnSubNiveles = subniveles)
}else stop("No se ha podido conectar al servidor.")
# Deshacerse del tag <string> que no permite usar xmlTreeParse
# y luege obtener datos
temp <- htmlRequest %>% XML::htmlParse(asText = TRUE) %>%
XML::xpathSApply("//string", XML::xmlValue) %>%
XML::xmlTreeParse() %>% XML::xmlRoot() %>%
XML::xmlSApply(function(x) XML::xmlSApply(x,
XML::xmlValue)) %>% t()
# Corregir series para las que el sistema retorna valores vacíos
# para determinadas fechas (v.gr. fines de semana)
if (class(temp) == "list") {
temp <- sapply(temp,
function(x) {if (is.na(x[3])) x <- c(x, "NA"); x}) %>% t()
}
#Formato de datos
temp <- as_tibble(temp)
colnames(temp) <-  c("Indicador", "Fecha", "Valor")
#Elimina advertencia por generación de NA's
suppressWarnings(temp$Valor <-
as.numeric(temp$Valor))
library(magrittr)
library(tibble)
library(dplyr)
if (!as.character(ind) %in% cods$Indicador) next
serverResponse <- httr::status_code(httr::GET(url))
if (serverResponse == 200) {
htmlRequest <- RCurl::getForm(baseSource,
tcIndicador = ind, tcFechaInicio = inicio,
tcFechaFinal = fin, tcNombre = nombre,
tnSubNiveles = subniveles)
}else stop("No se ha podido conectar al servidor.")
# Deshacerse del tag <string> que no permite usar xmlTreeParse
# y luege obtener datos
temp <- htmlRequest %>% XML::htmlParse(asText = TRUE) %>%
XML::xpathSApply("//string", XML::xmlValue) %>%
XML::xmlTreeParse() %>% XML::xmlRoot() %>%
XML::xmlSApply(function(x) XML::xmlSApply(x,
XML::xmlValue)) %>% t()
# Corregir series para las que el sistema retorna valores vacíos
# para determinadas fechas (v.gr. fines de semana)
if (class(temp) == "list") {
temp <- sapply(temp,
function(x) {if (is.na(x[3])) x <- c(x, "NA"); x}) %>% t()
}
#Formato de datos
temp <- tibble::as_tibble(temp)
colnames(temp) <-  c("Indicador", "Fecha", "Valor")
#Elimina advertencia por generación de NA's
suppressWarnings(temp$Valor <-
as.numeric(temp$Valor))
indicador, inicio="11/02/1989", fin = "hoy",
subniveles = "N", nombre= "me"
inicio="11/02/1989"
fin = "hoy"
nombre= "me"
subniveles = "N"
subniveles = "S"
if (fin == "hoy") fin = strftime(Sys.time(),"%d/%m/%Y")
url <- paste("http://indicadoreseconomicos.bccr.fi.cr/",
"indicadoreseconomicos/WebServices/wsIndicadoresEconomicos.asmx",
sep = "")
baseSource <- paste(url,"/ObtenerIndicadoresEconomicosXML",
sep = "")
indicador = 1
if (!as.character(ind) %in% cods$Indicador) next
serverResponse <- httr::status_code(httr::GET(url))
if (serverResponse == 200) {
htmlRequest <- RCurl::getForm(baseSource,
tcIndicador = ind, tcFechaInicio = inicio,
tcFechaFinal = fin, tcNombre = nombre,
tnSubNiveles = subniveles)
}else stop("No se ha podido conectar al servidor.")
# Deshacerse del tag <string> que no permite usar xmlTreeParse
# y luege obtener datos
temp <- htmlRequest %>% XML::htmlParse(asText = TRUE) %>%
XML::xpathSApply("//string", XML::xmlValue) %>%
XML::xmlTreeParse() %>% XML::xmlRoot() %>%
XML::xmlSApply(function(x) XML::xmlSApply(x,
XML::xmlValue)) %>% t()
# Corregir series para las que el sistema retorna valores vacíos
# para determinadas fechas (v.gr. fines de semana)
if (class(temp) == "list") {
temp <- sapply(temp,
function(x) {if (is.na(x[3])) x <- c(x, "NA"); x}) %>% t()
}
#Formato de datos
temp <- tibble::as_tibble(temp)
colnames(temp) <-  c("Indicador", "Fecha", "Valor")
#Elimina advertencia por generación de NA's
suppressWarnings(temp$Valor <-
as.numeric(temp$Valor))
ind = 1
if (!as.character(ind) %in% cods$Indicador) next
serverResponse <- httr::status_code(httr::GET(url))
if (serverResponse == 200) {
htmlRequest <- RCurl::getForm(baseSource,
tcIndicador = ind, tcFechaInicio = inicio,
tcFechaFinal = fin, tcNombre = nombre,
tnSubNiveles = subniveles)
}else stop("No se ha podido conectar al servidor.")
# Deshacerse del tag <string> que no permite usar xmlTreeParse
# y luege obtener datos
temp <- htmlRequest %>% XML::htmlParse(asText = TRUE) %>%
XML::xpathSApply("//string", XML::xmlValue) %>%
XML::xmlTreeParse() %>% XML::xmlRoot() %>%
XML::xmlSApply(function(x) XML::xmlSApply(x,
XML::xmlValue)) %>% t()
# Corregir series para las que el sistema retorna valores vacíos
# para determinadas fechas (v.gr. fines de semana)
if (class(temp) == "list") {
temp <- sapply(temp,
function(x) {if (is.na(x[3])) x <- c(x, "NA"); x}) %>% t()
}
#Formato de datos
temp <- tibble::as_tibble(temp)
colnames(temp) <-  c("Indicador", "Fecha", "Valor")
#Elimina advertencia por generación de NA's
suppressWarnings(temp$Valor <-
as.numeric(temp$Valor))
temp
temp$Fecha <- as.Date(temp$Fecha, "%Y-%m-%d")
x <- dplyr::left_join(cods, "Indicador")
x <- dplyr::left_join(cods, Indicador)
cods
cods <- cods
x <- dplyr::left_join(cods, Indicador)
help("left_join")
x <- dplyr::left_join(cods, "Indicador")
x <- temp %>% dplyr::left_join(cods, Indicador) %>%
dplyr::select(-Indicador, -Periodicidad) %>% spread(Nombre,
Valor)
temp
x <- temp %>% dplyr::left_join(cods, Indicador)
x <- temp %>% dplyr::left_join(cods, "Indicador)
x <- temp %>% dplyr::left_join(cods, "Indicador")
x
library(DatosBCCR)
datos <- DescargarDatosBCCR(1, subniveles = "S")
library(DatosBCCR)
datos <- DescargarDatosBCCR(1, subniveles = "S")
library(DatosBCCR)
datos <- DescargarDatosBCCR(1, subniveles = "S")
datos
datos <- DescargarDatosBCCR(1, subniveles = "N")
datos
datos <- DescargarDatosBCCR(c(317, 318), subniveles = "N")
datos
